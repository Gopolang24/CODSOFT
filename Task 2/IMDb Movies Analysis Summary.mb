###IMDb Movies Analysis Summary
##Overview
The analysis focuses on the IMDb Movies dataset, examining various aspects such as data statistics, missing values, data preprocessing, and building regression models for predicting movie ratings. The dataset includes information about movies, covering features like name, genre, director, actors, year, duration, votes, and ratings.

##Data Exploration
###First Few Rows
The dataset begins with a glimpse of the first five rows, showcasing features like Name, Genre, Director, Actor 1, Actor 2, Actor 3, Year, Duration, Votes, and Rating.

##Dataset Information
The dataset contains entries with information about multiple columns. Data types include integers, floats, and objects. Key observations include missing values in columns like 'Year,' 'Duration,' 'Votes,' 'Genre,' and 'Actors.'

##Descriptive Statistics
Descriptive statistics reveal essential information about the dataset, including the count, mean, standard deviation, minimum, 25th percentile, median (50th percentile), 75th percentile, and maximum values for numerical features.

##Data Cleaning
##Handling Missing Values
The analysis addresses missing values in the dataset. The 'Year,' 'Duration,' 'Votes,' 'Genre,' and 'Actors' columns were processed to impute or drop missing values appropriately.

##Exploratory Data Visualization
Visualizations explore the distribution of movie ratings, missing values, genre counts, movies per actor, movies per director, and the relationship between votes/duration and ratings.

##Feature Engineering
Additional features were created to enhance analysis, including 'Movies_Per_Actor,' 'Total_Votes_Per_Actor,' 'Total_Votes_Per_Movie,' 'Movies_Per_Director,' and 'Movies_Per_Year.'

##Regression Models
Several regression models, including Linear Regression, Random Forest, Decision Tree, XGBoost, Gradient Boosting, LightGBM, CatBoost, K-Nearest Neighbors, and Support Vector Regression, were employed to predict movie ratings. Evaluation metrics such as Mean Squared Error (MSE) and R-squared Score were utilized for model assessment.

##Model Evaluation Results
Evaluation results for each regression model include MSE and R-squared Score. Visualizations such as Residuals Plot provide insights into model performance.

##Top 10 Analysis
Top 10 lists were generated for movies based on ratings, genres, actors, and directors, offering a glimpse into the most prominent aspects of the dataset.

##Word Clouds
Word clouds were created to visually represent the most frequent words in the 'Director,' 'Genre,' and 'Name' columns, providing a unique perspective on the dataset.

##Data Preview:
The DataFrame 'Dropped_imdb' is presented, showcasing the retained features after dropping unnecessary columns. It includes additional engineered features like 'Total_Votes_Per_Actor,' 'Total_Votes_Per_Movie,' 'Movies_Per_Director,' and 'Movies_Per_Year.'

#CODE
import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns 
from sklearn.linear_model import LinearRegression
from sklearn.impute import SimpleImputer
from sklearn.pipeline import make_pipeline
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from xgboost import XGBRegressor
from lightgbm import LGBMRegressor
from catboost import CatBoostRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

# Create a visuals folder
visuals_folder = 'visuals'
os.makedirs(visuals_folder, exist_ok=True)

#Load data set
imdb_ds = pd.read_csv('IMDb_Movies_India.csv', encoding='latin1')

#Print the first 5 rows of the dataset
print('First 5 Rows: \n', imdb_ds.head())

#Print dataset info
print('\nDataset Info:\n', imdb_ds.info())

# Calculate the percentage of missing values for each column
missing_percentage = (imdb_ds.isnull().sum() / len(imdb_ds)) * 100

# Create a DataFrame to display missing percentage
missing_df = pd.DataFrame({'Column': imdb_ds.columns, 'Missing Percentage': missing_percentage})

# Sort the DataFrame by missing percentage in descending order
missing_df = missing_df.sort_values(by='Missing Percentage', ascending=False)

# Display the result
print(missing_df)

# Convert data types
imdb_ds['Year'] = pd.to_numeric(imdb_ds['Year'].astype(str).str.extract('(\d+)', expand=False), errors='coerce').astype('Int64')
imdb_ds['Duration'] = pd.to_numeric(imdb_ds['Duration'].str.extract('(\d+)', expand=False), errors='coerce')
imdb_ds['Votes'] = pd.to_numeric(imdb_ds['Votes'], errors='coerce')

# Display updated data types
print('\nUpdated Data Types:\n', imdb_ds.dtypes)

#Describe the dataset
print('\nData Description:\n', imdb_ds.describe())

# Visualize the distribution of movie ratings using a histogram
plt.figure(figsize=(10, 6))
sns.histplot(imdb_ds['Rating'], bins=20, kde=True, color='skyblue')
plt.title('Distribution of Movie Ratings')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.savefig(os.path.join(visuals_folder, 'movie_ratings_distribution.png'))
plt.show()

#Check and visualise missing values
missing_data = imdb_ds.isnull().sum()
print('\nMissing Data Counts:\n', missing_data)

#Plotting bar graph to show missing values in each column
plt.bar(missing_data.index, missing_data.values, width=0.5, align='center')  # Adjust the width as needed
plt.xlabel('Features')
plt.ylabel('Number of Missing Values')
plt.title('Missing Value Analysis')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent clipping of rotated labels
plt.savefig(os.path.join(visuals_folder,  'missing_value_analysis.png'))
plt.show()

def handle_director_missing_values(imdb_ds):
    # Handling missing values by filling with a placeholder value or dropping rows
    imdb_ds.fillna({'Director': 'Unknown'}, inplace=True)

    # Check if there are multiple directors
    imdb_ds['MultipleDirectors'] = imdb_ds['Director'].str.contains(',')

    # Display the movies with multiple directors
    movies_with_multiple_directors = imdb_ds[imdb_ds['MultipleDirectors']]
    print("\nMovies with Multiple Directors:\n", movies_with_multiple_directors[['Name', 'Director', 'MultipleDirectors']])

    # Display the count of movies with multiple directors
    print("\nNumber of Movies with Multiple Directors:", movies_with_multiple_directors.shape[0])

    # Group by 'Director' and count the number of movies directed by each director
    director_counts = imdb_ds.groupby('Director')['Name'].count().reset_index()

    # Display directors who have directed multiple movies
    directors_with_multiple_movies = director_counts[director_counts['Name'] > 1]
    print("\nDirectors with Multiple Movies:\n", directors_with_multiple_movies)

    # Display the count of directors with multiple movies
    print("\nNumber of Directors with Multiple Movies:", directors_with_multiple_movies.shape[0])

    return imdb_ds
imdb_ds = handle_director_missing_values(imdb_ds)

class DataFrameImputer(BaseEstimator, TransformerMixin):
    def __init__(self, strategy='mean'):
        self.strategy = strategy
        self.imputer = SimpleImputer(strategy=self.strategy)

    def fit(self, X, y=None):
        self.imputer.fit(X)
        return self

    def transform(self, X):
        return pd.DataFrame(self.imputer.transform(X), columns=X.columns)

def impute_missing_feature(imdb_ds, feature):
    # Drop rows with missing values in the specified feature for training the model
    train_data = imdb_ds.dropna(subset=[feature])

    # Prepare data for training
    features = ['Duration', 'Votes', 'Rating']  # Replace with relevant features
    features.remove(feature)  # Exclude the target feature
    X_train = train_data[features]
    y_train = train_data[feature]

    # Create a pipeline with custom imputer and linear regression
    model = Pipeline([
        ('imputer', DataFrameImputer(strategy='mean')),
        ('linear_regression', LinearRegression())
    ])

    # Train the model
    model.fit(X_train, y_train)

    # Predict missing values
    X_missing = imdb_ds.loc[imdb_ds[feature].isnull(), features]
    X_missing_imputed = pd.DataFrame(model.named_steps['imputer'].transform(X_missing), columns=features)
    imdb_ds.loc[imdb_ds[feature].isnull(), feature] = model.predict(X_missing_imputed)

    return imdb_ds

imdb_ds = impute_missing_feature(imdb_ds, 'Votes')
imdb_ds = impute_missing_feature(imdb_ds, 'Duration')
imdb_ds = impute_missing_feature(imdb_ds, 'Rating')

#Drop year missing values
imdb_ds.dropna(subset=['Year'], inplace=True)
print('Year', imdb_ds['Year'].head())

def handle_genre_missing_values(imdb_ds):
    most_common_genre = imdb_ds['Genre'].mode().iloc[0]
    imdb_ds['Genre'].fillna(most_common_genre, inplace=True)
    return imdb_ds

imdb_ds = handle_genre_missing_values(imdb_ds)

def handle_actor_missing_values(imdb_ds):
    most_common_actor_1 = imdb_ds['Actor 1'].mode().iloc[0]
    most_common_actor_2 = imdb_ds['Actor 2'].mode().iloc[0]
    most_common_actor_3 = imdb_ds['Actor 3'].mode().iloc[0]

    imdb_ds['Actor 1'] = imdb_ds['Actor 1'].fillna(most_common_actor_1)
    imdb_ds['Actor 2'] = imdb_ds['Actor 2'].fillna(most_common_actor_2)
    imdb_ds['Actor 3'] = imdb_ds['Actor 3'].fillna(most_common_actor_3)

    return imdb_ds

imdb_ds = handle_actor_missing_values(imdb_ds)

#Check and visualise missing values
missing_data = imdb_ds.isnull().sum()
print('\nMissing Data Counts:\n', missing_data)

#Plotting bar graph to show missing values in each column
plt.bar(missing_data.index, missing_data.values, width=0.5, align='center')  # Adjust the width as needed
plt.xlabel('Features')
plt.ylabel('Number of Missing Values')
plt.title('Missing Value Analysis')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent clipping of rotated labels
plt.savefig(os.path.join(visuals_folder, 'Number_of_Missing_Values.png'))
plt.show()

def analyze_and_concat(imdb_ds):
    # Count occurrences of each unique genre
    genre_counts = imdb_ds['Genre'].str.split(', ', expand=True).stack().value_counts()
    # Print counts in sorted order by genre name
    sorted_genre_counts = genre_counts.sort_index()
    imdb_ds['Genre_Counts'] = imdb_ds['Genre'].apply(lambda x: sorted_genre_counts[x.split(', ')[0]])

    # Count number of movies per actor
    actors = pd.concat([imdb_ds['Actor 1'], imdb_ds['Actor 2'], imdb_ds['Actor 3']], ignore_index=True)
    actor_counts = actors.value_counts()
    imdb_ds['Movies_Per_Actor'] = imdb_ds['Actor 1'].map(actor_counts) + imdb_ds['Actor 2'].map(actor_counts) + imdb_ds['Actor 3'].map(actor_counts)

    # Total votes per actor
    actors_votes_df = pd.DataFrame({'Actor': actors, 'Votes': imdb_ds['Votes']})
    actor_votes_sum = actors_votes_df.groupby('Actor')['Votes'].sum()
    imdb_ds['Total_Votes_Per_Actor'] = imdb_ds['Actor 1'].map(actor_votes_sum) + imdb_ds['Actor 2'].map(actor_votes_sum) + imdb_ds['Actor 3'].map(actor_votes_sum)

    # Total votes per movie
    imdb_ds['Total_Votes_Per_Movie'] = imdb_ds['Votes']

    # Total movies per director
    director_movie_counts = imdb_ds['Director'].value_counts()
    imdb_ds['Movies_Per_Director'] = imdb_ds['Director'].map(director_movie_counts)
    
    # Count movies per year
    imdb_ds['Movies_Per_Year'] = imdb_ds.groupby('Year')['Name'].transform('count')

    return imdb_ds

imdb_ds = analyze_and_concat(imdb_ds)

print('First 5 Rows: \n', imdb_ds.columns)

# Line plot for the count of movies per year
plt.figure(figsize=(14, 8))
sns.lineplot(x='Year', y='Movies_Per_Year', data=imdb_ds, marker='o')
plt.title('Number of Movies per Year')
plt.xlabel('Year')
plt.ylabel('Number of Movies')
plt.savefig(os.path.join(visuals_folder, 'Number_of_movies_per_year.png'))
plt.show()

# Count plot for the total movies per director
plt.figure(figsize=(14, 8))
sns.countplot(x='Movies_Per_Director', data=imdb_ds)
plt.title('Total Movies per Director')
plt.xlabel('Total Movies')
plt.ylabel('Count of Directors')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder,'movies_per_director.png'))
plt.show()

# Count plot for genre counts
plt.figure(figsize=(14, 8))
sns.countplot(x='Genre_Counts', data=imdb_ds)
plt.title('Genre Counts')
plt.xlabel('Genre Counts')
plt.ylabel('Count of Movies')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'genre_counts.png'))
plt.show()

# Count plot for movies per actor
plt.figure(figsize=(14, 8))
sns.countplot(x='Movies_Per_Actor', data=imdb_ds)
plt.title('Count of Movies per Actor')
plt.xlabel('Movies Per Actor')
plt.ylabel('Count of Actors')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'movies_per_actor.png'))
plt.show()

# Box Plot to compare the distribution of movie ratings across different genres
# Split the 'Genre' column into multiple rows
genres = imdb_ds['Genre'].str.split(', ', expand=True).stack()

# Create a DataFrame with 'Name' and 'Rating' for each genre
genre_ratings = pd.DataFrame({'Name': imdb_ds['Name'].repeat(imdb_ds['Genre'].str.count(', ') + 1),
                               'Genre': genres.values,
                               'Rating': imdb_ds['Rating'].repeat(imdb_ds['Genre'].str.count(', ') + 1)})

# Box plot to compare the distribution of movie ratings across different genres
plt.figure(figsize=(14, 8))
sns.boxplot(x='Genre', y='Rating', data=genre_ratings)
plt.title('Distribution of Movie Ratings Across Different Genres')
plt.xlabel('Genre')
plt.ylabel('Rating')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'distribution_of_movie_ratings.png'))
plt.show()

# Scatter plot for 'Votes' vs 'Rating'
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Votes', y='Rating', data=imdb_ds)
plt.title('Scatter Plot of Votes vs Rating')
plt.xlabel('Votes')
plt.ylabel('Rating')
plt.savefig(os.path.join(visuals_folder, 'votes_vs_rating.png'))
plt.show()

# Scatter plot for 'Duration' vs 'Rating'
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Duration', y='Rating', data=imdb_ds)
plt.title('Scatter Plot of Duration vs Rating')
plt.xlabel('Duration')
plt.ylabel('Rating')
plt.savefig(os.path.join(visuals_folder, 'Scatter_Plot_of_Duration_vs_Rating.png'))
plt.show()

sns.pairplot(imdb_ds[['Rating', 'Votes', 'Duration']], height=5)
plt.suptitle('Pair Plot of Rating, Votes, and Duration', y=1.02)
plt.savefig(os.path.join(visuals_folder, 'Pair_Plot_of_Rating_Votes_and_Durations.png'))
plt.show()

plt.figure(figsize=(14, 8))
sns.barplot(x='Genre', y='Rating', data=genre_ratings, ci=None)
plt.title('Average Rating for Each Genre')
plt.xlabel('Genre')
plt.ylabel('Average Rating')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'Average Rating for Each Genre.png'))
plt.show()

top_10_movies = imdb_ds.nlargest(10, 'Rating')
plt.figure(figsize=(12, 8))
plt.barh(top_10_movies['Name'], top_10_movies['Rating'], color='skyblue')
plt.xlabel('Rating')
plt.ylabel('Movie Title')
plt.title('Top 10 Movies Based on Ratings')
plt.gca().invert_yaxis()  # To have the highest rating at the top
plt.savefig(os.path.join(visuals_folder, 'Top 10 Movies Based on Ratings.png'))
plt.show()

top_10_genres = imdb_ds['Genre'].value_counts().nlargest(10)
plt.figure(figsize=(12, 8))
top_10_genres.plot(kind='bar', color='skyblue')
plt.xlabel('Genre')
plt.ylabel('Frequency')
plt.title('Top 10 Genres')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'Top 10 Genres.png'))
plt.show()

actors_columns = ['Actor 1', 'Actor 2', 'Actor 3']
all_actors = pd.concat([imdb_ds[col] for col in actors_columns])
top_10_actors = all_actors.value_counts().nlargest(10)
plt.figure(figsize=(12, 8))
top_10_actors.plot(kind='bar', color='skyblue')
plt.xlabel('Actor')
plt.ylabel('Frequency')
plt.title('Top 10 Actors')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'Top 10 Actors.png'))
plt.show()

top_10_directors = imdb_ds['Director'].value_counts().nlargest(10)
plt.figure(figsize=(12, 8))
top_10_directors.plot(kind='bar', color='skyblue')
plt.xlabel('Director')
plt.ylabel('Frequency')
plt.title('Top 10 Directors')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.savefig(os.path.join(visuals_folder, 'Top 10 Directors.png'))
plt.show()

# Drop specified columns
Droped_imbd = imdb_ds.drop(['Name', 'Genre', 'Director', 'Actor 1', 'Actor 2', 'Actor 3'], axis=1)

# Print dropped_imbd
print('\nDropped_imbd\n', Droped_imbd)

# Split the data into input (X) and output (y)
X = Droped_imbd.drop('Rating', axis=1)  # Features
y = Droped_imbd['Rating']  # Target variable

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)

# Initialize regression models
linear_regression_model = LinearRegression()
random_forest_model = RandomForestRegressor()
decision_tree_model = DecisionTreeRegressor()
xgb_model = XGBRegressor()
gradient_boosting_model = GradientBoostingRegressor()
lgbm_model = LGBMRegressor()
catboost_model = CatBoostRegressor()
knn_model = KNeighborsRegressor()
svr_model = SVR()

# List of models
models = [
    ("Linear Regression", linear_regression_model),
    ("Random Forest", random_forest_model),
    ("Decision Tree", decision_tree_model),
    ("XGBoost", xgb_model),
    ("Gradient Boosting", gradient_boosting_model),
    ("LightGBM", lgbm_model),
    ("CatBoost", catboost_model),
    ("K-Nearest Neighbors", knn_model),
    ("Support Vector Regression", svr_model),
]

def evaluate_model(model, X_test, y_test):
    # Make predictions on the test set
    y_pred = model.predict(X_test)

    # Print evaluation metrics
    print(f"\nEvaluation Metrics for {type(model).__name__}:")
    print(f"Mean Squared Error: {mean_squared_error(y_test, y_pred)}")
    print(f"R-squared Score: {r2_score(y_test, y_pred)}")

    return mean_squared_error(y_test, y_pred), r2_score(y_test, y_pred)

# Fit and evaluate each model
for model_name, model in models:
    # Fit the model to the training data
    model.fit(X_train, y_train)
    
    # Evaluate the model
    mse, r2 = evaluate_model(model, X_test, y_test)

from yellowbrick.regressor import ResidualsPlot

visualizer = ResidualsPlot(linear_regression_model)
visualizer.fit(X_train, y_train)
visualizer.score(X_test, y_test)
visualizer.show()

from wordcloud import WordCloud

wordcloud = WordCloud(width=800, height=400, background_color='white').generate(' '.join(imdb_ds['Director']))
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Word Cloud for Directors')
plt.savefig(os.path.join(visuals_folder, 'Word_Cloud_for_Movie_Titles.png'))
plt.show()

wordcloud = WordCloud(width=800, height=400, background_color='white').generate(' '.join(imdb_ds['Genre']))
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Word Cloud for Movie Genres')
plt.savefig(os.path.join(visuals_folder, 'Word_Cloud_for_Directors.png'))
plt.show()

wordcloud = WordCloud(width=800, height=400, background_color='white').generate(' '.join(imdb_ds['Name']))
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Word Cloud for Movie Titles')
plt.savefig(os.path.join(visuals_folder, 'Word_Cloud_for_Movie_Titles.png'))
plt.show()

#Output
First 5 Rows: 
                                  Name    Year Duration  ...       Actor 1             Actor 2          Actor 3
0                                         NaN      NaN  ...      Manmauji              Birbal  Rajendra Bhatia
1  #Gadhvi (He thought he was Gandhi) -2019.0  109 min  ...  Rasika Dugal      Vivek Ghamande    Arvind Jangid
2                         #Homecoming -2021.0   90 min  ...  Sayani Gupta   Plabita Borthakur       Roy Angana
3                             #Yaaram -2019.0  110 min  ...       Prateik          Ishita Raj  Siddhant Kapoor
4                   ...And Once Again -2010.0  105 min  ...  Rajat Kapoor  Rituparna Sengupta      Antara Mali

[5 rows x 10 columns]
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 15509 entries, 0 to 15508
Data columns (total 10 columns):
 #   Column    Non-Null Count  Dtype  
---  ------    --------------  -----  
 0   Name      15509 non-null  object 
 1   Year      14981 non-null  float64
 2   Duration  7240 non-null   object 
 3   Genre     13632 non-null  object 
 4   Rating    7919 non-null   float64
 5   Votes     7920 non-null   object 
 6   Director  14984 non-null  object 
 7   Actor 1   13892 non-null  object
 8   Actor 2   13125 non-null  object
 9   Actor 3   12365 non-null  object
dtypes: float64(2), object(8)
memory usage: 1.2+ MB

Dataset Info:
 None
            Column  Missing Percentage
Duration  Duration           53.317429
Rating      Rating           48.939326
Votes        Votes           48.932878
Actor 3    Actor 3           20.272100
Actor 2    Actor 2           15.371720
Genre        Genre           12.102650
Actor 1    Actor 1           10.426204
Year          Year            3.404475
Director  Director            3.385131
Name          Name            0.000000

Updated Data Types:
 Name         object
Year          Int64
Duration    float64
Genre        object
Rating      float64
Votes       float64
Director     object
Actor 1      object
Actor 2      object
Actor 3      object
dtype: object

Data Description:
               Year     Duration       Rating        Votes
count      14981.0  7240.000000  7919.000000  6548.000000
mean   1987.012215   128.126519     5.841621   120.839493
std      25.416689    28.912724     1.381777   194.211390
min         1913.0     2.000000     1.100000     5.000000
25%         1968.0   110.000000     4.900000    13.000000
50%         1991.0   131.000000     6.000000    35.000000
75%         2009.0   147.000000     6.800000   123.000000
max         2022.0   321.000000    10.000000   999.000000

Missing Data Counts:
 Name           0
Year         528
Duration    8269
Genre       1877
Rating      7590
Votes       8961
Director     525
Actor 1     1617
Actor 2     2384
Actor 3     3144
dtype: int64

Movies with Multiple Directors:
 Empty DataFrame
Columns: [Name, Director, MultipleDirectors]
Index: []

Number of Movies with Multiple Directors: 0

Directors with Multiple Movies:
                   Director  Name
1             A. Bhimsingh    18
3           A. Jagannathan     5
5     A. Kodandarami Reddy     2
9                A. Rashid     2
10               A. Salaam    12
...                    ...   ...
5932         Ziaullah Khan     2
5933                 Zohra     2
5934           Zoya Akhtar     7
5935           Zubair Khan     2
5936               Zubeida     2

[2043 rows x 2 columns]

Number of Directors with Multiple Movies: 2043
Year 1    2019
2    2021
3    2019
4    2010
5    1997
Name: Year, dtype: Int64

Missing Data Counts:
 Name                 0
Year                 0
Duration             0
Genre                0
Rating               0
Votes                0
Director             0
Actor 1              0
Actor 2              0
Actor 3              0
MultipleDirectors    0
dtype: int64
First 5 Rows: 
 Index(['Name', 'Year', 'Duration', 'Genre', 'Rating', 'Votes', 'Director',
       'Actor 1', 'Actor 2', 'Actor 3', 'MultipleDirectors', 'Genre_Counts',
       'Movies_Per_Actor', 'Total_Votes_Per_Actor', 'Total_Votes_Per_Movie',
       'Movies_Per_Director', 'Movies_Per_Year'],
      dtype='object')

Data columns (total 10 columns):
 #   Column    Non-Null Count  Dtype  
---  ------    --------------  -----  
 0   Name      15509 non-null  object 
 1   Year      14981 non-null  float64
 2   Duration  7240 non-null   object 
 3   Genre     13632 non-null  object 
 4   Rating    7919 non-null   float64
 5   Votes     7920 non-null   object 
 6   Director  14984 non-null  object 
 7   Actor 1   13892 non-null  object
 8   Actor 2   13125 non-null  object
 9   Actor 3   12365 non-null  object
dtypes: float64(2), object(8)
memory usage: 1.2+ MB

Dataset Info:
 None
            Column  Missing Percentage
Duration  Duration           53.317429
Rating      Rating           48.939326
Votes        Votes           48.932878
Actor 3    Actor 3           20.272100
Actor 2    Actor 2           15.371720
Genre        Genre           12.102650
Actor 1    Actor 1           10.426204
Year          Year            3.404475
Director  Director            3.385131
Name          Name            0.000000

Updated Data Types:
 Name         object
Year          Int64
Duration    float64
Genre        object
Rating      float64
Votes       float64
Director     object
Actor 1      object
Actor 2      object
Actor 3      object
dtype: object

Data Description:
               Year     Duration       Rating        Votes
count      14981.0  7240.000000  7919.000000  6548.000000
mean   1987.012215   128.126519     5.841621   120.839493
std      25.416689    28.912724     1.381777   194.211390
min         1913.0     2.000000     1.100000     5.000000
25%         1968.0   110.000000     4.900000    13.000000
50%         1991.0   131.000000     6.000000    35.000000
75%         2009.0   147.000000     6.800000   123.000000
max         2022.0   321.000000    10.000000   999.000000

Missing Data Counts:
 Name           0
Year         528
Duration    8269
Genre       1877
Rating      7590
Votes       8961
Director     525
Actor 1     1617
Actor 2     2384
Actor 3     3144
dtype: int64

Movies with Multiple Directors:
 Empty DataFrame
Columns: [Name, Director, MultipleDirectors]
Index: []

Number of Movies with Multiple Directors: 0

Directors with Multiple Movies:
                   Director  Name
1             A. Bhimsingh    18
3           A. Jagannathan     5
5     A. Kodandarami Reddy     2
9                A. Rashid     2
10               A. Salaam    12
...                    ...   ...
5932         Ziaullah Khan     2
5933                 Zohra     2
5934           Zoya Akhtar     7
5935           Zubair Khan     2
5936               Zubeida     2

[2043 rows x 2 columns]

Number of Directors with Multiple Movies: 2043
Year 1    2019
2    2021
3    2019
4    2010
5    1997
Name: Year, dtype: Int64

Missing Data Counts:
 Name                 0
Year                 0
Duration             0
Genre                0
Rating               0
Votes                0
Director             0
Actor 1              0
Actor 2              0
Actor 3              0
MultipleDirectors    0
dtype: int64
First 5 Rows: 
 Index(['Name', 'Year', 'Duration', 'Genre', 'Rating', 'Votes', 'Director',
       'Actor 1', 'Actor 2', 'Actor 3', 'MultipleDirectors', 'Genre_Counts',
       'Movies_Per_Actor', 'Total_Votes_Per_Actor', 'Total_Votes_Per_Movie',
       'Movies_Per_Director', 'Movies_Per_Year'],
      dtype='object')

##Dropped_imbd
        Year    Duration    Rating       Votes  ...  Total_Votes_Per_Actor  Total_Votes_Per_Movie  Movies_Per_Director  Movies_Per_Year
1      2019  109.000000  7.000000    8.000000  ...             122.246164               8.000000                    1              410      
2      2021   90.000000  5.887327   86.942313  ...             128.839493              86.942313                    1              392      
3      2019  110.000000  4.400000   35.000000  ...             996.246578              35.000000                    1              410      
4      2010  105.000000  5.870425   99.740993  ...            1013.564035              99.740993                    7              195      
5      1997  147.000000  4.700000  827.000000  ...           10200.747297             827.000000                   17              141      
...     ...         ...       ...         ...  ...                    ...                    ...                  ...              ...      
15504  1988  125.456805  4.600000   11.000000  ...            7252.194182              11.000000                    4              212      
15505  1999  129.000000  4.500000  655.000000  ...           11603.561539             655.000000                    8              184      
15506  2005  127.553147  5.844959  120.839493  ...           10647.541587             120.839493                    1              346      
15507  1988  127.553147  5.844959  120.839493  ...          205274.607775             120.839493                  497              212      
15508  1998  130.000000  6.200000   20.000000  ...           20495.445965              20.000000                   18              163      

[14981 rows x 11 columns]

##Evaluation Metrics for LinearRegression:
Mean Squared Error: 0.951478465911569
R-squared Score: 0.01651372784458982
